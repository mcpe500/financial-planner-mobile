package com.example.financialplannerapp.utils

import android.content.Context
import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt // Required for Authenticators
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

object SecurityUtils {

    private const val PREFS_SECURITY = "prefs_security"
    private const val KEY_PIN_ENABLED = "key_pin_enabled"
    private const val KEY_ENCRYPTED_PIN_HASH = "key_encrypted_pin_hash"
    private const val KEY_BIOMETRIC_ENABLED = "key_biometric_enabled"
    private const val SHARED_PREF_KEY_IV = "pin_encryption_iv" // For storing the Initialization Vector

    // Keystore and Cipher Constants
    private const val KEYSTORE_PROVIDER = "AndroidKeyStore"
    private const val KEY_ALIAS_PIN = "pin_encryption_key"
    private const val CIPHER_TRANSFORMATION = "AES/GCM/NoPadding"
    private const val GCM_IV_LENGTH = 12 // GCM recommended IV length is 12 bytes
    private const val GCM_TAG_LENGTH = 128 // GCM recommended tag length is 128 bits

    // Keystore Key Management
    @Throws(Exception::class)
    private fun getOrCreateSecretKey(): SecretKey {
        val keyStore = KeyStore.getInstance(KEYSTORE_PROVIDER)
        keyStore.load(null)

        if (keyStore.containsAlias(KEY_ALIAS_PIN)) {
            val entry = keyStore.getEntry(KEY_ALIAS_PIN, null) as? KeyStore.SecretKeyEntry
            entry?.secretKey?.let { return it }
        }

        val keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, KEYSTORE_PROVIDER)
        val builder = KeyGenParameterSpec.Builder(
            KEY_ALIAS_PIN,
            KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
        )
            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            .setKeySize(256) // AES-256

        // setUserAuthenticationRequired(true) could be added here for more security,
        // but makes key retrieval more complex (requires biometric/lock screen auth).
        // For now, keeping it simpler.

        keyGenerator.init(builder.build())
        return keyGenerator.generateKey()
    }

    // Encryption
    @Throws(Exception::class)
    private fun encryptData(context: Context, data: String, secretKey: SecretKey): Pair<String, String>? {
        return try {
            val cipher = Cipher.getInstance(CIPHER_TRANSFORMATION)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey)
            val iv = cipher.iv // Get the IV generated by the cipher
            val encryptedData = cipher.doFinal(data.toByteArray(Charsets.UTF_8))

            val ivBase64 = Base64.encodeToString(iv, Base64.NO_WRAP)
            val encryptedDataBase64 = Base64.encodeToString(encryptedData, Base64.NO_WRAP)

            // Save IV to SharedPreferences
            val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
            prefs.edit().putString(SHARED_PREF_KEY_IV, ivBase64).apply()

            Pair(encryptedDataBase64, ivBase64)
        } catch (e: Exception) {
            e.printStackTrace() // Log error
            null
        }
    }

    // Decryption
    @Throws(Exception::class)
    private fun decryptData(context: Context, encryptedDataB64: String, secretKey: SecretKey): String? {
        return try {
            // Retrieve IV from SharedPreferences
            val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
            val ivBase64 = prefs.getString(SHARED_PREF_KEY_IV, null) ?: return null // IV is crucial

            val iv = Base64.decode(ivBase64, Base64.NO_WRAP)
            val encryptedData = Base64.decode(encryptedDataB64, Base64.NO_WRAP)

            val cipher = Cipher.getInstance(CIPHER_TRANSFORMATION)
            val spec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)

            val decryptedData = cipher.doFinal(encryptedData)
            String(decryptedData, Charsets.UTF_8)
        } catch (e: Exception) {
            e.printStackTrace() // Log error, especially AEADBadTagException
            // Clear potentially compromised data if decryption fails
            saveEncryptedPinHash(context, null) // This will clear hash and IV
            null
        }
    }


    // PIN Enabled Preference
    fun isPinLockEnabled(context: Context): Boolean {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        return prefs.getBoolean(KEY_PIN_ENABLED, false)
    }

    fun setPinLockEnabled(context: Context, enabled: Boolean) {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        prefs.edit().putBoolean(KEY_PIN_ENABLED, enabled).apply()
        // If PIN lock is disabled, also clear the PIN itself for security
        if (!enabled) {
            saveEncryptedPinHash(context, null)
        }
    }

    // Biometric Enabled Preference
    fun isBiometricAuthEnabled(context: Context): Boolean {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        return prefs.getBoolean(KEY_BIOMETRIC_ENABLED, false)
    }

    fun setBiometricAuthEnabled(context: Context, enabled: Boolean) {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        prefs.edit().putBoolean(KEY_BIOMETRIC_ENABLED, enabled).apply()
    }

    // PIN Set Check (Now more accurate)
    fun isPinSet(context: Context): Boolean {
        return getDecryptedPinHash(context) != null
    }

    fun saveEncryptedPinHash(context: Context, pinHash: String?) {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        if (pinHash != null) {
            try {
                val secretKey = getOrCreateSecretKey()
                val encryptionResult = encryptData(context, pinHash, secretKey)
                if (encryptionResult != null) {
                    prefs.edit()
                        .putString(KEY_ENCRYPTED_PIN_HASH, encryptionResult.first)
                        // IV is already saved by encryptData, but good to be explicit if changing that
                        // .putString(SHARED_PREF_KEY_IV, encryptionResult.second)
                        .apply()
                } else {
                    // Encryption failed, clear existing stored hash and IV
                    prefs.edit()
                        .remove(KEY_ENCRYPTED_PIN_HASH)
                        .remove(SHARED_PREF_KEY_IV)
                        .apply()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                // Ensure data is cleared on error during key generation or encryption
                prefs.edit()
                    .remove(KEY_ENCRYPTED_PIN_HASH)
                    .remove(SHARED_PREF_KEY_IV)
                    .apply()
            }
        } else {
            // Clear the stored encrypted hash and the IV
            prefs.edit()
                .remove(KEY_ENCRYPTED_PIN_HASH)
                .remove(SHARED_PREF_KEY_IV)
                .apply()
        }
    }

    // This function now returns the DECRYPTED PIN hash
    fun getDecryptedPinHash(context: Context): String? {
        val prefs = context.getSharedPreferences(PREFS_SECURITY, Context.MODE_PRIVATE)
        val encryptedPinHashB64 = prefs.getString(KEY_ENCRYPTED_PIN_HASH, null)

        if (encryptedPinHashB64 != null) {
            try {
                val secretKey = getOrCreateSecretKey()
                return decryptData(context, encryptedPinHashB64, secretKey)
            } catch (e: Exception) {
                e.printStackTrace()
                // If decryption fails for any reason (e.g. key issue, data corruption)
                // Treat as no PIN set and clear potentially invalid data.
                saveEncryptedPinHash(context, null) // Clears hash and IV
                return null
            }
        }
        return null
    }

    // Biometric Hardware Check
    fun canAuthenticateWithBiometrics(context: Context): Boolean {
        val biometricManager = BiometricManager.from(context)
        val authenticators = BiometricManager.Authenticators.BIOMETRIC_STRONG or BiometricManager.Authenticators.BIOMETRIC_WEAK
        
        when (biometricManager.canAuthenticate(authenticators)) {
            BiometricManager.BIOMETRIC_SUCCESS -> {
                // The user can authenticate with biometrics, continue with the authentication process
                return true
            }
            BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {
                // No biometric features available on this device.
                return false
            }
            BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE -> {
                // Biometric features are currently unavailable.
                return false
            }
            BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {
                // The user hasn't associated any biometric credentials with their account.
                return false
            }
            // Other error codes may exist, treat them as inability to authenticate
            else -> {
                return false
            }
        }
    }
}
