from these PLANS please create the markdown plans after understanding(so make a markdown file with the plan and the deeper steps and further details to execute the plans):
<PLANS>
Of course. Here is a comprehensive, step-by-step implementation plan to build the requested transaction management features into your existing financial planner application.

This plan addresses both the backend (Node.js, Express, Supabase) and the frontend (Jetpack Compose), ensuring they work together seamlessly. It incorporates best practices like the Repository pattern, ViewModel, and a dual data-source approach (local Room DB with Supabase for remote sync).

### **Step 1: Backend Setup & Database Schema**

First, we'll set up the database schema in Supabase. This schema is based on your `database-schema.md` and `category-tag-management-plan.md` files.

#### **1.1. Supabase SQL Schema**

Execute the following SQL commands in your Supabase SQL Editor to create the necessary tables. This script includes tables for users, categories, tags, and transactions, along with the join table for the many-to-many relationship between transactions and tags.

```sql
-- Create users table (Assuming it might not exist yet)
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL UNIQUE,
    name TEXT,
    avatar_url TEXT,
    google_id TEXT,
    role TEXT DEFAULT 'user',
    password_hash TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    date_of_birth DATE,
    financial_goals TEXT,
    monthly_income NUMERIC,
    occupation TEXT,
    phone VARCHAR(20)
);

-- Create categories table
CREATE TABLE IF NOT EXISTS categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    parent_id UUID REFERENCES categories(id) ON DELETE SET NULL, -- Allows for sub-categories
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, name) -- Category names must be unique per user
);

-- Create tags table
CREATE TABLE IF NOT EXISTS tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, name) -- Tag names must be unique per user
);

-- Create transactions table
CREATE TABLE IF NOT EXISTS transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    amount NUMERIC NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    date TIMESTAMPTZ NOT NULL,
    description TEXT,
    merchant_name TEXT,
    location TEXT,
    receipt_id TEXT,
    items JSONB,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    sync_status TEXT DEFAULT 'pending'
);

-- Create transaction_tags join table for many-to-many relationship
CREATE TABLE IF NOT EXISTS transaction_tags (
    transaction_id UUID NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (transaction_id, tag_id)
);
```

#### **1.2. Backend Type Definitions**

Update your backend type definitions to reflect the new database schema.

*   `financial-planner-mobile/financial-planner-backend/src/types/transaction.types.ts`:

    ```typescript
    export interface TransactionType {
        id: string;
        user_id: string;
        amount: number;
        type: 'expense' | 'income';
        category_id: string;
        date: string; // ISO date string
        description?: string;
        merchant_name?: string;
        location?: string;
        receipt_id?: string;
        items?: any[];
        notes?: string;
        tags?: string[]; // Will be handled by the join table
        created_at: string;
        updated_at: string;
        sync_status: 'synced' | 'pending' | 'error';
    }
    
    export interface TransactionPayload {
        amount: number;
        type: 'expense' | 'income';
        category_id: string;
        date: string; // ISO date string
        description?: string;
        merchant_name?: string;
        location?: string;
        receipt_id?: string;
        items?: any[];
        notes?: string;
        tag_ids?: string[]; // Changed from `tags` to `tag_ids`
    }
    ```

#### **1.3. Backend Routes and Controllers**

Update your transaction controller to handle the new features. The existing `transaction.controller.ts` already has a good structure for OCR and manual creation. We will enhance it.

*   `financial-planner-mobile/financial-planner-backend/src/controllers/transaction.controller.ts`: Add `assignTagsToTransaction` to the controller.

    ```typescript
    // ... existing imports
    import { AuthRequest } from "../types/request.types";
    import database from "../services/database.service";
    
    // ... (keep existing functions)
    
    export const assignTagsToTransaction = async (req: AuthRequest, res: Response): Promise<void> => {
        try {
            if (!req.user) {
                res.status(401).json({ message: "Authentication required" });
                return;
            }
            const { id } = req.params;
            const { tag_ids }: { tag_ids: string[] } = req.body;
    
            if (!Array.isArray(tag_ids)) {
                res.status(400).json({ success: false, message: "tag_ids must be an array" });
                return;
            }
    
            // First, remove existing tags for this transaction to avoid duplicates
            await database.removeAllTagsFromTransaction(id);
    
            // Then, assign new tags
            if (tag_ids.length > 0) {
                await database.assignTagsToTransaction(id, tag_ids);
            }
    
            res.status(200).json({ success: true, message: "Tags assigned successfully" });
        } catch (error: any) {
            console.error("Error assigning tags:", error);
            res.status(500).json({ success: false, message: "Failed to assign tags" });
        }
    };
    ```

*   `financial-planner-mobile/financial-planner-backend/src/routes/transaction.routes.ts`: Add the new route for assigning tags.

    ```typescript
    // ... (existing imports)
    import {
      // ... existing controller imports
      assignTagsToTransaction
    } from "../controllers/transaction.controller";
    
    const router = Router();
    
    // ... (existing routes)
    
    // POST /api/transactions/:id/tags - Assign tags to a transaction
    router.post("/:id/tags", authenticate, assignTagsToTransaction);
    
    // ... (existing routes)
    
    export default router;
    ```

#### **1.4. Backend Database Service**

Now, update `database.service.ts` to include methods for interacting with the new tables.

*   `financial-planner-mobile/financial-planner-backend/src/services/database.service.ts`:

    ```typescript
    // ... (inside the `adapter` implementation for Supabase)
    
    // Tag methods
    // ... (existing createTag, getTags)
    assignTagsToTransaction: async (transactionId: string, tagIds: string[]) => {
        const assignments = tagIds.map(tagId => ({
            transaction_id: transactionId,
            tag_id: tagId
        }));
        const { error } = await supabase
            .from('transaction_tags')
            .insert(assignments);
        if (error) throw error;
    },
    
    removeAllTagsFromTransaction: async (transactionId: string) => {
        const { error } = await supabase
            .from('transaction_tags')
            .delete()
            .eq('transaction_id', transactionId);
        if (error) throw error;
    },
    
    // ... (the rest of the file)
    ```

### **Step 2: Frontend (Jetpack Compose) Setup**

Now, let's set up the frontend to handle these new features.

#### **2.1. Room Database Entities and DAOs**

Create the necessary Room entities and DAOs for local storage.

*   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/data/local/model/TransactionEntity.kt`: This file already exists, but ensure it matches the required fields.

    ```kotlin
    package com.example.financialplannerapp.data.local.model
    
    import androidx.room.Entity
    import androidx.room.PrimaryKey
    import java.util.Date
    
    @Entity(tableName = "transactions")
    data class TransactionEntity(
        @PrimaryKey
        val id: String, // Use UUID from backend as primary key
        val userId: String,
        val amount: Double,
        val type: String, // "income" or "expense"
        val categoryId: String?,
        val date: Date,
        val description: String?,
        val merchantName: String?,
        val location: String?,
        val receiptId: String?,
        val items: String?, // JSON string
        val notes: String?,
        val tags: String?, // JSON string of tag names or IDs
        val createdAt: Long = System.currentTimeMillis(),
        val updatedAt: Long = System.currentTimeMillis(),
        var syncStatus: String // "synced", "pending", "error"
    )
    ```

*   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/data/local/dao/TransactionDao.kt`: Update this DAO to handle the new `TransactionEntity`.

    ```kotlin
    package com.example.financialplannerapp.data.local.dao
    
    import androidx.room.*
    import com.example.financialplannerapp.data.local.model.TransactionEntity
    import kotlinx.coroutines.flow.Flow
    
    @Dao
    interface TransactionDao {
        @Insert(onConflict = OnConflictStrategy.REPLACE)
        suspend fun insertTransaction(transaction: TransactionEntity)
    
        @Insert(onConflict = OnConflictStrategy.REPLACE)
        suspend fun insertAll(transactions: List<TransactionEntity>)
    
        @Update
        suspend fun updateTransaction(transaction: TransactionEntity)
    
        @Query("DELETE FROM transactions WHERE id = :id")
        suspend fun deleteTransactionById(id: String)
    
        @Query("SELECT * FROM transactions WHERE userId = :userId ORDER BY date DESC")
        fun getAllTransactionsByUser(userId: String): Flow<List<TransactionEntity>>
    
        @Query("SELECT * FROM transactions WHERE syncStatus = 'pending'")
        suspend fun getPendingTransactions(): List<TransactionEntity>
    }
    ```

*   Update `AppDatabase.kt` to ensure `TransactionEntity` is included and the version is incremented.
    *   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/data/local/AppDatabase.kt`:

        ```kotlin
        // ... (inside @Database annotation)
        entities = [
            // ... other entities
            TransactionEntity::class,
            // ... other entities
        ],
        version = 5, // <--- INCREMENT THE VERSION
        // ...
        ```

#### **2.2. Repository and ViewModel**

Create the `TransactionRepository` and `TransactionViewModel` to manage the data flow.

*   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/data/repository/TransactionRepository.kt`:

    ```kotlin
    package com.example.financialplannerapp.data.repository
    
    import com.example.financialplannerapp.data.local.dao.TransactionDao
    import com.example.financialplannerapp.data.local.model.TransactionEntity
    import com.example.financialplannerapp.data.remote.ApiService
    import com.example.financialplannerapp.data.model.TransactionPayload
    import com.example.financialplannerapp.utils.TokenManager
    import kotlinx.coroutines.flow.Flow
    import java.lang.Exception
    
    class TransactionRepository(
        private val transactionDao: TransactionDao,
        private val apiService: ApiService,
        private val tokenManager: TokenManager
    ) {
    
        // TRANSAKSI#1: Get all transactions from the local database
        fun getLocalTransactions(userId: String): Flow<List<TransactionEntity>> {
            return transactionDao.getAllTransactionsByUser(userId)
        }
    
        // TRANSAKSI#3: Insert a transaction locally
        suspend fun insertLocalTransaction(transaction: TransactionEntity) {
            transactionDao.insertTransaction(transaction)
        }
    
        // TRANSAKSI#7: Update a transaction locally
        suspend fun updateLocalTransaction(transaction: TransactionEntity) {
            transactionDao.updateTransaction(transaction.copy(syncStatus = "pending"))
        }
    
        // TRANSAKSI#7: Delete a transaction locally
        suspend fun deleteLocalTransaction(id: String) {
            transactionDao.deleteTransactionById(id)
            // Here you might want to log the deletion to sync it later
        }
    
        // Sync pending transactions to the backend
        suspend fun syncPendingTransactions() {
            val token = tokenManager.getAuthHeader() ?: return
            val pendingTransactions = transactionDao.getPendingTransactions()
            for (transaction in pendingTransactions) {
                try {
                    val payload = TransactionPayload(
                        amount = transaction.amount,
                        type = transaction.type,
                        category_id = transaction.categoryId ?: "",
                        description = transaction.description,
                        date = transaction.date.toInstant().toString(),
                        // ... map other fields
                    )
                    // This is a simplified example. You'd need a more robust sync mechanism
                    // that handles create, update, and delete operations.
                    // For now, we assume pending means "needs to be created on backend".
                    val response = apiService.createTransaction(token, payload)
                    if (response.isSuccessful) {
                        // Mark as synced
                        updateLocalTransaction(transaction.copy(syncStatus = "synced"))
                    }
                } catch (e: Exception) {
                    // Handle sync error
                }
            }
        }
    }
    ```

*   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/ui/viewmodel/TransactionViewModel.kt`:

    ```kotlin
    package com.example.financialplannerapp.ui.viewmodel
    
    import androidx.lifecycle.ViewModel
    import androidx.lifecycle.viewModelScope
    import com.example.financialplannerapp.data.local.model.TransactionEntity
    import com.example.financialplannerapp.data.repository.TransactionRepository
    import kotlinx.coroutines.flow.MutableStateFlow
    import kotlinx.coroutines.flow.StateFlow
    import kotlinx.coroutines.flow.asStateFlow
    import kotlinx.coroutines.launch
    
    class TransactionViewModel(private val repository: TransactionRepository, private val userId: String) : ViewModel() {
    
        private val _transactions = MutableStateFlow<List<TransactionEntity>>(emptyList())
        val transactions: StateFlow<List<TransactionEntity>> = _transactions.asStateFlow()
    
        init {
            loadTransactions()
        }
    
        private fun loadTransactions() {
            viewModelScope.launch {
                repository.getLocalTransactions(userId).collect {
                    _transactions.value = it
                }
            }
        }
    
        fun addTransaction(transaction: TransactionEntity) {
            viewModelScope.launch {
                repository.insertLocalTransaction(transaction)
                // Optionally trigger a sync
                repository.syncPendingTransactions()
            }
        }
    
        // Add other methods for update, delete etc.
    }
    
    ```

#### **2.3. Frontend UI Screens**

Now, create the Jetpack Compose screens for transaction management.

*   **TRANSAKSI#1: `TransactionHistoryScreen`**

    This screen will display the list of transactions from the local Room database.

    `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/ui/screen/transaction/TransactionHistoryScreen.kt`:

    ```kotlin
    package com.example.financialplannerapp.ui.screen.transaction
    
    import androidx.compose.foundation.layout.*
    import androidx.compose.foundation.lazy.LazyColumn
    import androidx.compose.foundation.lazy.items
    import androidx.compose.material3.*
    import androidx.compose.runtime.Composable
    import androidx.compose.runtime.collectAsState
    import androidx.compose.runtime.getValue
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.unit.dp
    import androidx.lifecycle.viewmodel.compose.viewModel
    import com.example.financialplannerapp.data.local.model.TransactionEntity
    
    @Composable
    fun TransactionHistoryScreen(
        viewModel: TransactionViewModel // You'll need a factory to provide this
    ) {
        val transactions by viewModel.transactions.collectAsState()
    
        Scaffold(
            topBar = {
                TopAppBar(title = { Text("Transaction History") })
            }
        ) { padding ->
            LazyColumn(
                modifier = Modifier
                    .padding(padding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(transactions) { transaction ->
                    TransactionItem(transaction)
                }
            }
        }
    }
    
    @Composable
    fun TransactionItem(transaction: TransactionEntity) {
        Card(modifier = Modifier.fillMaxWidth()) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(text = transaction.description ?: "No Description", style = MaterialTheme.typography.bodyLarge)
                    Text(text = transaction.date.toString(), style = MaterialTheme.typography.bodySmall)
                }
                Text(
                    text = "${if (transaction.type == "expense") "-" else "+"}${transaction.amount}",
                    color = if (transaction.type == "expense") Color.Red else Color.Green
                )
            }
        }
    }
    ```

*   **TRANSAKSI#2 & #3: `AddTransactionScreen`**

    This screen provides a form for manual transaction input.

    `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/ui/screen/transaction/AddTransactionScreen.kt`:

    ```kotlin
    package com.example.financialplannerapp.ui.screen.transaction
    
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.unit.dp
    import androidx.navigation.NavController
    import com.example.financialplannerapp.data.local.model.TransactionEntity
    import com.example.financialplannerapp.ui.viewmodel.TransactionViewModel
    import java.util.*
    
    @Composable
    fun AddTransactionScreen(
        navController: NavController,
        viewModel: TransactionViewModel
    ) {
        var amount by remember { mutableStateOf("") }
        var description by remember { mutableStateOf("") }
        var type by remember { mutableStateOf("expense") } // "expense" or "income"
    
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Add New Transaction", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))
    
            OutlinedTextField(
                value = amount,
                onValueChange = { amount = it },
                label = { Text("Amount") },
                modifier = Modifier.fillMaxWidth()
            )
            OutlinedTextField(
                value = description,
                onValueChange = { description = it },
                label = { Text("Description") },
                modifier = Modifier.fillMaxWidth()
            )
            // Add more fields for category, date, etc.
    
            Button(
                onClick = {
                    val newTransaction = TransactionEntity(
                        id = UUID.randomUUID().toString(),
                        userId = "current_user_id", // Replace with actual user ID
                        amount = amount.toDoubleOrNull() ?: 0.0,
                        description = description,
                        type = type,
                        date = Date(),
                        syncStatus = "pending",
                        categoryId = null, // Set a default or from a dropdown
                        items = null,
                        location = null,
                        merchantName = null,
                        notes = null,
                        receiptId = null,
                        tags = null
                    )
                    viewModel.addTransaction(newTransaction)
                    navController.popBackStack()
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Save Transaction")
            }
        }
    }
    
    ```

*   **TRANSAKSI#4: Scan Receipt**
    The `ScanReceiptScreen` you already have is a great starting point. The key is to connect its result to the `AddTransactionScreen`.
    1.  In `ScanReceiptViewModel`, after a successful OCR (`ReceiptOCRState.Success`), don't save it directly. Instead, navigate to the `AddTransactionScreen` and pass the OCR data as arguments.
    2.  The `AddTransactionScreen` will then be pre-filled with the data from the OCR, allowing the user to confirm or edit before saving.

*   **TRANSAKSI#5 & #6: Voice and QR Input**
    These follow the same pattern as the OCR scan:
    1.  Create `VoiceInputScreen.kt` and `QRScanScreen.kt`.
    2.  These screens will handle the input and processing (either locally or via the backend).
    3.  Upon successful processing, they will navigate to `AddTransactionScreen`, passing the extracted data to pre-fill the form.

#### **2.4. Navigation**

Finally, wire up the new screens in your navigation graph.

*   `financial-planner-mobile/financial-planner-frontend-jetpack-compose/app/src/main/java/com/example/financialplannerapp/ui/navigation/AppNavigation.kt`:

    ```kotlin
    // ... (inside the NavHost)
    
    composable("transactions") {
        TransactionHistoryScreen(
            // You'll need to provide the ViewModel here, likely using Hilt or a factory
        )
    }
    
    composable("add_transaction") {
        AddTransactionScreen(
            navController = navController,
            // Provide ViewModel
        )
    }
    
    // Add routes for OCR, voice, and QR screens as well
    composable("scan_receipt") {
        ScanReceiptScreen(navController = navController)
    }
    
    // ...
    ```

### **Summary of Implementation Steps**

1.  **Backend**:
    *   Set up Supabase tables using the provided SQL.
    *   Update backend TypeScript types for `Transaction`.
    *   Enhance the `transaction.controller.ts` and `transaction.routes.ts` for new actions like tagging.
    *   Implement the corresponding methods in `database.service.ts`.

2.  **Frontend**:
    *   Update `TransactionEntity.kt` and `TransactionDao.kt` for Room.
    *   Increment the `AppDatabase` version.
    *   Implement `TransactionRepository.kt` to handle both local (Room) and remote (API) data sources.
    *   Implement `TransactionViewModel.kt` to expose data from the repository to the UI.
    *   Create UI screens (`TransactionHistoryScreen`, `AddTransactionScreen`, etc.) using Jetpack Compose.
    *   Update `AppNavigation.kt` to include routes to the new screens.
    *   Modify `ScanReceiptScreen`, `VoiceInputScreen`, etc., to navigate to `AddTransactionScreen` with the processed data.

This comprehensive plan provides a clear path to implementing the requested transaction features, ensuring a robust architecture that supports both offline and online functionality.
</PLANS>
after that please implement the plans
and for each steps made(small or medium or big steps create a markdown file in the @/markdown-steps/ folder and then please keep track of it)